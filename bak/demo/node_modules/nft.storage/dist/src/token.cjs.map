{"version":3,"file":"token.cjs","sources":["../../src/token.js"],"sourcesContent":["import * as API from './lib/interface.js'\nimport { Blob, FormData } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\n\n/** @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions */\n\n/**\n * @template {API.TokenInput} T\n * @implements {API.Token<T>}\n */\nexport class Token {\n  /**\n   * @param {API.CIDString} ipnft\n   * @param {API.EncodedURL} url\n   * @param {API.Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {API.Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {API.TokenInput} T\n   * @param {{data: API.Encoded<T, [[Blob, URL]]>}} token\n   * @returns {API.Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n}\n\n/**\n * @template T\n * @param {API.Encoded<T, [[Blob, URL]]>} input\n * @param {EmbedOptions} options\n * @returns {API.Encoded<T, [[Blob, URL]]>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {API.TokenInput} T\n * @param {API.EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expcet EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {API.EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is API.EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {API.TokenInput} T\n * @param {API.Encoded<T, [[Blob, Blob]]>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [form, meta] = mapValueWith(\n    input,\n    isBlob,\n    encodeBlob,\n    new FormData(),\n    []\n  )\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {FormData} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[FormData, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {API.Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {API.Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {API.Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {API.Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output = /** @type {API.Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, API.Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [state, /** @type {API.Encoded<T, [[I, O]]>} */ (output)]\n}\n"],"names":["GATEWAY","toGatewayURL","FormData","Blob"],"mappings":"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"}