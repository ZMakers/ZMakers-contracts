/** @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions */
/**
 * @template {API.TokenInput} T
 * @implements {API.Token<T>}
 */
export class Token<T extends API.TokenInput> implements API.Token<T> {
    /**
     * @template {API.TokenInput} T
     * @param {{data: API.Encoded<T, [[Blob, URL]]>}} token
     * @returns {API.Encoded<T, [[Blob, URL]]>}
     */
    static embed<T_1 extends API.TokenInput>({ data }: {
        data: API.MatchRecord<T_1, (input: Blob) => URL>;
    }): API.MatchRecord<T_1, (input: Blob) => URL>;
    /**
     * @param {API.CIDString} ipnft
     * @param {API.EncodedURL} url
     * @param {API.Encoded<T, [[Blob, URL]]>} data
     */
    constructor(ipnft: API.CIDString, url: API.EncodedURL, data: API.Encoded<T, [[Blob, URL]]>);
    /** @readonly */
    readonly ipnft: API.CIDString;
    /** @readonly */
    readonly url: API.EncodedURL;
    /** @readonly */
    readonly data: API.MatchRecord<T, (input: Blob) => URL>;
    /**
     * @returns {API.Encoded<T, [[Blob, URL]]>}
     */
    embed(): API.Encoded<T, [[Blob, URL]]>;
}
export function embed<T>(input: API.MatchRecord<T, (input: Blob) => URL>, options: EmbedOptions): API.MatchRecord<T, (input: Blob) => URL>;
export function decode<T extends API.TokenInput>({ ipnft, url, data }: API.EncodedToken<T>, paths: Set<string>): Token<T>;
export function encode<T extends API.TokenInput>(input: API.MatchRecord<T, (input: Blob) => Blob>): FormData;
export function mapWith<T, I, X, O, State>(input: API.MatchRecord<T, (input: I) => X>, p: (input: any, state: State, path: PropertyKey[]) => input is X, f: (state: State, input: X, path: PropertyKey[]) => [State, O], state: State): API.MatchRecord<T, (input: I) => O>;
export type EmbedOptions = import('./gateway.js').GatewayURLOptions;
import * as API from "./lib/interface.js";
import { Blob as Blob_1 } from "./platform.js";
import { FormData } from "./platform.js";
//# sourceMappingURL=token.d.ts.map